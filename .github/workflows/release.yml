name: Release Publish

on:
  push:
    tags: ["v*"]

env:
  REGISTRY: ghcr.io/${{ github.repository }}
  COSIGN_EXPERIMENTAL: "1"

jobs:
  release:
    runs-on: ubuntu-latest
    timeout-minutes: 120
    permissions:
      contents: write
      packages: write
      id-token: write
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          submodules: recursive

      - uses: docker/setup-qemu-action@29109295f81e9208d7d86ff1c6c12d2833863392 # v3

      - uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3

      - uses: sigstore/cosign-installer@f713795cb21599bc4e5c4b58cbad1da852d7eeb9 # v3

      - name: Install security tooling
        run: |
          curl --fail --location --proto '=https' --tlsv1.3 --retry 3 --retry-delay 2 --silent --show-error \
            https://raw.githubusercontent.com/anchore/syft/main/install.sh | sudo sh -s -- -b /usr/local/bin
          curl --fail --location --proto '=https' --tlsv1.3 --retry 3 --retry-delay 2 --silent --show-error \
            https://raw.githubusercontent.com/anchore/grype/main/install.sh | sudo sh -s -- -b /usr/local/bin
          curl --fail --location --proto '=https' --tlsv1.3 --retry 3 --retry-delay 2 --silent --show-error \
            https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sudo sh -s -- -b /usr/local/bin

      - name: Login to GHCR
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract version
        id: version
        run: |
          VERSION=${GITHUB_REF#refs/tags/}
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Version: ${VERSION}"

      - name: Build & Push
        run: |
          docker buildx bake --push \
            --set *.args.SOURCE_DATE_EPOCH=$(date +%s) \
            --set *.cache-from=type=gha \
            --set *.cache-to=type=gha,mode=max

      - name: Prepare attestation workspace
        run: mkdir -p sbom sbom-bundle attestations scan

      - name: Generate SBOMs and JDK metadata
        run: |
          SYFT_VERSION="$(syft version | head -n 1 | sed 's/^Version: //')"
          for tag in $(docker buildx bake --print | jq -r '.target | keys[]'); do
            echo "Generating SBOM for ${tag}..."
            syft ${REGISTRY}:${tag} -o cyclonedx-json > sbom/${tag}.cdx.json
            cp sbom/${tag}.cdx.json sbom-bundle/${tag}.cdx.json

            ./scripts/attest_jdk_resolution.sh ${tag} attestations/jdk-resolution-${tag}.json

            SBOM_SHA="$(sha256sum sbom/${tag}.cdx.json | awk '{print $1}')"
            GENERATED_AT="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
            jq -n \
              --arg target "${tag}" \
              --arg format "cyclonedx-json" \
              --arg syft_version "${SYFT_VERSION}" \
              --arg sbom_sha256 "${SBOM_SHA}" \
              --arg generated_at "${GENERATED_AT}" \
              '{target: $target, format: $format, syft_version: $syft_version, sbom_sha256: $sbom_sha256, generated_at: $generated_at}' \
              > attestations/sbom-metadata-${tag}.json
          done
          echo "Generated $(ls sbom/*.cdx.json | wc -l) SBOM files"

      - name: Scan images
        run: |
          set +e
          for tag in $(docker buildx bake --print | jq -r '.target | keys[]'); do
            IMAGE_REF="${REGISTRY}:${tag}"
            trivy image --exit-code 1 --severity HIGH,CRITICAL \
              --format json --output scan/trivy-${tag}.json \
              ${IMAGE_REF}
            echo "$?" > scan/trivy-exit-${tag}.txt

            grype ${IMAGE_REF} -o json --fail-on high > scan/grype-${tag}.json
            echo "$?" > scan/grype-exit-${tag}.txt
          done
          set -e

      - name: Generate scan attestations
        run: |
          TRIVY_VERSION="$(trivy --version | head -n 1 | sed 's/^Version: //')"
          GRYPE_VERSION="$(grype version | head -n 1 | sed 's/^Version: //')"
          for tag in $(docker buildx bake --print | jq -r '.target | keys[]'); do
            export TARGET="${tag}"
            export TRIVY_VERSION
            export GRYPE_VERSION
            export TRIVY_EXIT="$(cat scan/trivy-exit-${tag}.txt)"
            export GRYPE_EXIT="$(cat scan/grype-exit-${tag}.txt)"
            python3 <<'PY'
import json
import os
from datetime import datetime, timezone

target = os.environ["TARGET"]
trivy_path = f"scan/trivy-{target}.json"
grype_path = f"scan/grype-{target}.json"

def count_trivy(data):
    counts = {}
    for result in data.get("Results", []):
        for vuln in result.get("Vulnerabilities") or []:
            sev = vuln.get("Severity", "UNKNOWN")
            counts[sev] = counts.get(sev, 0) + 1
    return counts

def count_grype(data):
    counts = {}
    for match in data.get("matches", []):
        sev = match.get("vulnerability", {}).get("severity", "Unknown")
        counts[sev] = counts.get(sev, 0) + 1
    return counts

with open(trivy_path, "r", encoding="utf-8") as fh:
    trivy_data = json.load(fh)
with open(grype_path, "r", encoding="utf-8") as fh:
    grype_data = json.load(fh)

payload = {
    "target": target,
    "generated_at": datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ"),
    "trivy": {
        "version": os.environ["TRIVY_VERSION"],
        "exit_code": int(os.environ["TRIVY_EXIT"]),
        "counts": count_trivy(trivy_data),
    },
    "grype": {
        "version": os.environ["GRYPE_VERSION"],
        "exit_code": int(os.environ["GRYPE_EXIT"]),
        "counts": count_grype(grype_data),
    },
}

with open(f"attestations/scan-{target}.json", "w", encoding="utf-8") as fh:
    json.dump(payload, fh, indent=2)
PY
          done

      - name: Upload scan artifacts
        uses: actions/upload-artifact@b4b15b8c7c6ac21ea08fcf65892d2ee8f75cf882 # v4.4.3
        with:
          name: scan-artifacts
          path: scan/*.json

      - name: Sign & Attest
        run: |
          for tag in $(docker buildx bake --print | jq -r '.target | keys[]'); do
            echo "Signing ${tag}..."
            cosign sign --yes ${REGISTRY}:${tag}

            echo "Attesting JDK resolution for ${tag}..."
            cosign attest --yes --predicate attestations/jdk-resolution-${tag}.json --type https://artagon.dev/attestations/jdk-resolution/v1 ${REGISTRY}:${tag}

            echo "Attesting SBOM metadata for ${tag}..."
            cosign attest --yes --predicate attestations/sbom-metadata-${tag}.json --type https://artagon.dev/attestations/sbom-metadata/v1 ${REGISTRY}:${tag}

            echo "Attesting vulnerability scan for ${tag}..."
            cosign attest --yes --predicate attestations/scan-${tag}.json --type https://artagon.dev/attestations/vulnerability-scan/v1 ${REGISTRY}:${tag}

            if [[ -f sbom/${tag}.cdx.json ]]; then
              echo "Attesting SBOM for ${tag}..."
              cosign attest --yes --predicate sbom/${tag}.cdx.json --type cyclonedx ${REGISTRY}:${tag}
            fi
          done

      - name: Upload attestation artifacts
        uses: actions/upload-artifact@b4b15b8c7c6ac21ea08fcf65892d2ee8f75cf882 # v4.4.3
        with:
          name: attestations
          path: attestations/*.json

      - name: Enforce scan gates
        run: |
          for tag in $(docker buildx bake --print | jq -r '.target | keys[]'); do
            if [[ "$(cat scan/trivy-exit-${tag}.txt)" != "0" ]]; then
              echo "Trivy scan failed for ${tag}" >&2
              exit 1
            fi
            if [[ "$(cat scan/grype-exit-${tag}.txt)" != "0" ]]; then
              echo "Grype scan failed for ${tag}" >&2
              exit 1
            fi
          done

      - name: Create Release
        uses: softprops/action-gh-release@6da8fa9354ddfdc4aeace5fc48d7f679b5214090 # v2
        with:
          files: sbom-bundle/*.cdx.json
          generate_release_notes: true
          body: |
            ## Container Images Released üöÄ

            All 15 image variants have been built, signed, and published to GHCR.

            **Version**: ${{ steps.version.outputs.version }}
            **Registry**: `ghcr.io/${{ github.repository }}`

            ### Image Variants

            **Chainguard (Wolfi + musl)**:
            - `chainguard-jdk25`, `chainguard-jdk25-musl`
            - `chainguard-jdk26ea`, `chainguard-jdk26ea-musl`
            - `chainguard-jdk26valhalla`, `chainguard-jdk26valhalla-musl`

            **Google Distroless**:
            - `distroless-jre25`, `distroless-jre25-musl`
            - `distroless-jre26ea`, `distroless-jre26ea-musl`
            - `distroless-jre26valhalla`, `distroless-jre26valhalla-musl`

            **Red Hat UBI 9**:
            - `ubi9-jdk25`
            - `ubi9-jdk26ea`
            - `ubi9-jdk26valhalla`

            ### Security

            ‚úÖ All images signed with Cosign (keyless)
            ‚úÖ SBOM attestations attached (CycloneDX format)
            ‚úÖ In-toto attestations for JDK resolution and scan metadata
            ‚úÖ SLSA provenance available
            ‚úÖ Multi-architecture support (amd64/arm64)

            ### Verification

            ```bash
            # Verify signatures and attestations
            scripts/verify_supply_chain.sh ghcr.io/${{ github.repository }}:chainguard-jdk25

            # Verify signature
            COSIGN_EXPERIMENTAL=1 cosign verify ghcr.io/${{ github.repository }}:chainguard-jdk25

            # Download SBOM
            cosign download sbom ghcr.io/${{ github.repository }}:chainguard-jdk25

            # Verify attestation
            cosign verify-attestation --type cyclonedx ghcr.io/${{ github.repository }}:chainguard-jdk25
            ```

            ### Usage

            ```bash
            docker pull ghcr.io/${{ github.repository }}:chainguard-jdk25
            docker run --rm ghcr.io/${{ github.repository }}:chainguard-jdk25 java --version
            ```

            ---

            üìÑ **SBOMs**: Attached to this release
            üîê **Signatures**: Keyless Cosign with Rekor transparency log
            üìã **License**: AGPL-3.0 or Commercial (see LICENSE)

  digests:
    needs: release
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read
    outputs:
      digest_map: ${{ steps.digests.outputs.map }}
    steps:
      - uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3

      - name: Login to GHCR
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Resolve image digests
        id: digests
        run: |
          MAP=$(python3 <<'PY'
import json
import os
import subprocess

tags = os.environ["TAGS"].split()
image = os.environ["IMAGE"]
digest_map = {}

for tag in tags:
    result = subprocess.check_output(
        ["docker", "buildx", "imagetools", "inspect", f"{image}:{tag}", "--format", "{{json .Manifest.Digest}}"],
        text=True,
    ).strip().strip('\"')
    digest_map[tag] = result

print(json.dumps(digest_map))
PY
)
          echo "map=$MAP" >> "$GITHUB_OUTPUT"
        env:
          TAGS: "chainguard-jdk25-musl chainguard-jdk25 chainguard-jdk26ea-musl chainguard-jdk26ea chainguard-jdk26valhalla-musl chainguard-jdk26valhalla distroless-jre25 distroless-jre25-musl distroless-jre26ea distroless-jre26ea-musl distroless-jre26valhalla distroless-jre26valhalla-musl ubi9-jdk25 ubi9-jdk26ea ubi9-jdk26valhalla"
          IMAGE: ${{ env.REGISTRY }}

  provenance:
    needs: digests
    permissions:
      id-token: write
      packages: write
      contents: read
    strategy:
      fail-fast: false
      matrix:
        target:
          - chainguard-jdk25-musl
          - chainguard-jdk25
          - chainguard-jdk26ea-musl
          - chainguard-jdk26ea
          - chainguard-jdk26valhalla-musl
          - chainguard-jdk26valhalla
          - distroless-jre25
          - distroless-jre25-musl
          - distroless-jre26ea
          - distroless-jre26ea-musl
          - distroless-jre26valhalla
          - distroless-jre26valhalla-musl
          - ubi9-jdk25
          - ubi9-jdk26ea
          - ubi9-jdk26valhalla
    uses: slsa-framework/slsa-github-generator/.github/workflows/generator_container_slsa3.yml@v2.0.0
    with:
      image: ghcr.io/${{ github.repository }}
      digest: ${{ fromJSON(needs.digests.outputs.digest_map)[matrix.target] }}
    secrets:
      registry-username: ${{ github.actor }}
      registry-password: ${{ secrets.GITHUB_TOKEN }}
